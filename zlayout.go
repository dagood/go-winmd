// Copyright (c) Microsoft Corporation
// Licensed under the MIT License.

// Code generated by "genlayout"; DO NOT EDIT.

package winmd

import (
	"fmt"
	"github.com/microsoft/go-winmd/flags"
)

// Define tables struct

// Tables provides access to the tables and records stored in the #~ stream
// as defined in Â§II.24.2.6
type Tables struct {
	Assembly               Table[*Assembly]
	AssemblyRef            Table[*AssemblyRef]
	ClassLayout            Table[*ClassLayout]
	Constant               Table[*Constant]
	CustomAttribute        Table[*CustomAttribute]
	DeclSecurity           Table[*DeclSecurity]
	EventMap               Table[*EventMap]
	Event                  Table[*Event]
	ExportedType           Table[*ExportedType]
	Field                  Table[*Field]
	FieldLayout            Table[*FieldLayout]
	FieldMarshal           Table[*FieldMarshal]
	FieldRVA               Table[*FieldRVA]
	File                   Table[*File]
	GenericParam           Table[*GenericParam]
	GenericParamConstraint Table[*GenericParamConstraint]
	ImplMap                Table[*ImplMap]
	InterfaceImpl          Table[*InterfaceImpl]
	ManifestResource       Table[*ManifestResource]
	MemberRef              Table[*MemberRef]
	MethodDef              Table[*MethodDef]
	MethodImpl             Table[*MethodImpl]
	MethodSemantics        Table[*MethodSemantics]
	MethodSpec             Table[*MethodSpec]
	Module                 Table[*Module]
	ModuleRef              Table[*ModuleRef]
	NestedClass            Table[*NestedClass]
	Param                  Table[*Param]
	Property               Table[*Property]
	PropertyMap            Table[*PropertyMap]
	StandAloneSig          Table[*StandAloneSig]
	TypeDef                Table[*TypeDef]
	TypeRef                Table[*TypeRef]
	TypeSpec               Table[*TypeSpec]
}

func newTables(data []byte, stringHeap StringHeap, layout *layout) *Tables {
	var t Tables
	t.Assembly = newTable(data, stringHeap, layout, tableAssembly, func() *Assembly { return new(Assembly) })
	t.AssemblyRef = newTable(data, stringHeap, layout, tableAssemblyRef, func() *AssemblyRef { return new(AssemblyRef) })
	t.ClassLayout = newTable(data, stringHeap, layout, tableClassLayout, func() *ClassLayout { return new(ClassLayout) })
	t.Constant = newTable(data, stringHeap, layout, tableConstant, func() *Constant { return new(Constant) })
	t.CustomAttribute = newTable(data, stringHeap, layout, tableCustomAttribute, func() *CustomAttribute { return new(CustomAttribute) })
	t.DeclSecurity = newTable(data, stringHeap, layout, tableDeclSecurity, func() *DeclSecurity { return new(DeclSecurity) })
	t.EventMap = newTable(data, stringHeap, layout, tableEventMap, func() *EventMap { return new(EventMap) })
	t.Event = newTable(data, stringHeap, layout, tableEvent, func() *Event { return new(Event) })
	t.ExportedType = newTable(data, stringHeap, layout, tableExportedType, func() *ExportedType { return new(ExportedType) })
	t.Field = newTable(data, stringHeap, layout, tableField, func() *Field { return new(Field) })
	t.FieldLayout = newTable(data, stringHeap, layout, tableFieldLayout, func() *FieldLayout { return new(FieldLayout) })
	t.FieldMarshal = newTable(data, stringHeap, layout, tableFieldMarshal, func() *FieldMarshal { return new(FieldMarshal) })
	t.FieldRVA = newTable(data, stringHeap, layout, tableFieldRVA, func() *FieldRVA { return new(FieldRVA) })
	t.File = newTable(data, stringHeap, layout, tableFile, func() *File { return new(File) })
	t.GenericParam = newTable(data, stringHeap, layout, tableGenericParam, func() *GenericParam { return new(GenericParam) })
	t.GenericParamConstraint = newTable(data, stringHeap, layout, tableGenericParamConstraint, func() *GenericParamConstraint { return new(GenericParamConstraint) })
	t.ImplMap = newTable(data, stringHeap, layout, tableImplMap, func() *ImplMap { return new(ImplMap) })
	t.InterfaceImpl = newTable(data, stringHeap, layout, tableInterfaceImpl, func() *InterfaceImpl { return new(InterfaceImpl) })
	t.ManifestResource = newTable(data, stringHeap, layout, tableManifestResource, func() *ManifestResource { return new(ManifestResource) })
	t.MemberRef = newTable(data, stringHeap, layout, tableMemberRef, func() *MemberRef { return new(MemberRef) })
	t.MethodDef = newTable(data, stringHeap, layout, tableMethodDef, func() *MethodDef { return new(MethodDef) })
	t.MethodImpl = newTable(data, stringHeap, layout, tableMethodImpl, func() *MethodImpl { return new(MethodImpl) })
	t.MethodSemantics = newTable(data, stringHeap, layout, tableMethodSemantics, func() *MethodSemantics { return new(MethodSemantics) })
	t.MethodSpec = newTable(data, stringHeap, layout, tableMethodSpec, func() *MethodSpec { return new(MethodSpec) })
	t.Module = newTable(data, stringHeap, layout, tableModule, func() *Module { return new(Module) })
	t.ModuleRef = newTable(data, stringHeap, layout, tableModuleRef, func() *ModuleRef { return new(ModuleRef) })
	t.NestedClass = newTable(data, stringHeap, layout, tableNestedClass, func() *NestedClass { return new(NestedClass) })
	t.Param = newTable(data, stringHeap, layout, tableParam, func() *Param { return new(Param) })
	t.Property = newTable(data, stringHeap, layout, tableProperty, func() *Property { return new(Property) })
	t.PropertyMap = newTable(data, stringHeap, layout, tablePropertyMap, func() *PropertyMap { return new(PropertyMap) })
	t.StandAloneSig = newTable(data, stringHeap, layout, tableStandAloneSig, func() *StandAloneSig { return new(StandAloneSig) })
	t.TypeDef = newTable(data, stringHeap, layout, tableTypeDef, func() *TypeDef { return new(TypeDef) })
	t.TypeRef = newTable(data, stringHeap, layout, tableTypeRef, func() *TypeRef { return new(TypeRef) })
	t.TypeSpec = newTable(data, stringHeap, layout, tableTypeSpec, func() *TypeSpec { return new(TypeSpec) })
	return &t
}

// Define CodedTable function

// CodedTable returns the table associated to c.
func (t *Tables) CodedTable(c CodedIndex) *Table[Record] {
	switch c.table {
	case tableAssembly:
		return any(&t.Assembly).(*Table[Record])
	case tableAssemblyRef:
		return any(&t.AssemblyRef).(*Table[Record])
	case tableClassLayout:
		return any(&t.ClassLayout).(*Table[Record])
	case tableConstant:
		return any(&t.Constant).(*Table[Record])
	case tableCustomAttribute:
		return any(&t.CustomAttribute).(*Table[Record])
	case tableDeclSecurity:
		return any(&t.DeclSecurity).(*Table[Record])
	case tableEventMap:
		return any(&t.EventMap).(*Table[Record])
	case tableEvent:
		return any(&t.Event).(*Table[Record])
	case tableExportedType:
		return any(&t.ExportedType).(*Table[Record])
	case tableField:
		return any(&t.Field).(*Table[Record])
	case tableFieldLayout:
		return any(&t.FieldLayout).(*Table[Record])
	case tableFieldMarshal:
		return any(&t.FieldMarshal).(*Table[Record])
	case tableFieldRVA:
		return any(&t.FieldRVA).(*Table[Record])
	case tableFile:
		return any(&t.File).(*Table[Record])
	case tableGenericParam:
		return any(&t.GenericParam).(*Table[Record])
	case tableGenericParamConstraint:
		return any(&t.GenericParamConstraint).(*Table[Record])
	case tableImplMap:
		return any(&t.ImplMap).(*Table[Record])
	case tableInterfaceImpl:
		return any(&t.InterfaceImpl).(*Table[Record])
	case tableManifestResource:
		return any(&t.ManifestResource).(*Table[Record])
	case tableMemberRef:
		return any(&t.MemberRef).(*Table[Record])
	case tableMethodDef:
		return any(&t.MethodDef).(*Table[Record])
	case tableMethodImpl:
		return any(&t.MethodImpl).(*Table[Record])
	case tableMethodSemantics:
		return any(&t.MethodSemantics).(*Table[Record])
	case tableMethodSpec:
		return any(&t.MethodSpec).(*Table[Record])
	case tableModule:
		return any(&t.Module).(*Table[Record])
	case tableModuleRef:
		return any(&t.ModuleRef).(*Table[Record])
	case tableNestedClass:
		return any(&t.NestedClass).(*Table[Record])
	case tableParam:
		return any(&t.Param).(*Table[Record])
	case tableProperty:
		return any(&t.Property).(*Table[Record])
	case tablePropertyMap:
		return any(&t.PropertyMap).(*Table[Record])
	case tableStandAloneSig:
		return any(&t.StandAloneSig).(*Table[Record])
	case tableTypeDef:
		return any(&t.TypeDef).(*Table[Record])
	case tableTypeRef:
		return any(&t.TypeRef).(*Table[Record])
	case tableTypeSpec:
		return any(&t.TypeSpec).(*Table[Record])
	default:
		return nil
	}
}

// Define table enum

type table uint8

const (
	tableModule                 table = 0
	tableTypeRef                table = 1
	tableTypeDef                table = 2
	tableField                  table = 4
	tableMethodDef              table = 6
	tableParam                  table = 8
	tableInterfaceImpl          table = 9
	tableMemberRef              table = 10
	tableConstant               table = 11
	tableCustomAttribute        table = 12
	tableFieldMarshal           table = 13
	tableDeclSecurity           table = 14
	tableClassLayout            table = 15
	tableFieldLayout            table = 16
	tableStandAloneSig          table = 17
	tableEventMap               table = 18
	tableEvent                  table = 20
	tablePropertyMap            table = 21
	tableProperty               table = 23
	tableMethodSemantics        table = 24
	tableMethodImpl             table = 25
	tableModuleRef              table = 26
	tableTypeSpec               table = 27
	tableImplMap                table = 28
	tableFieldRVA               table = 29
	tableAssembly               table = 32
	tableAssemblyProcessor      table = 33
	tableAssemblyOS             table = 34
	tableAssemblyRef            table = 35
	tableAssemblyRefProcessor   table = 36
	tableAssemblyRefOS          table = 37
	tableFile                   table = 38
	tableExportedType           table = 39
	tableManifestResource       table = 40
	tableNestedClass            table = 41
	tableGenericParam           table = 42
	tableMethodSpec             table = 43
	tableGenericParamConstraint table = 44

	tableMax  = tableGenericParamConstraint + 1
	tableNone = tableMax
)

// Define table width

func (t table) width(la *layout) uint8 {
	switch t {
	case tableAssembly:
		return 4 + 2 + 2 + 2 + 2 + 4 + la.blobSize + la.stringSize + la.stringSize
	case tableAssemblyOS:
		return 4 + 4 + 4
	case tableAssemblyProcessor:
		return 4
	case tableAssemblyRef:
		return 2 + 2 + 2 + 2 + 4 + la.blobSize + la.stringSize + la.stringSize + la.blobSize
	case tableAssemblyRefOS:
		return 4 + 4 + 4 + la.simpleSizes[tableAssemblyRef]
	case tableAssemblyRefProcessor:
		return 4 + la.simpleSizes[tableAssemblyRef]
	case tableClassLayout:
		return 2 + 4 + la.simpleSizes[tableTypeDef]
	case tableConstant:
		return 1 + 1 + la.codedSizes[codedHasConstant] + la.blobSize
	case tableCustomAttribute:
		return la.codedSizes[codedHasCustomAttribute] + la.codedSizes[codedCustomAttributeType] + la.blobSize
	case tableDeclSecurity:
		return 2 + la.codedSizes[codedHasDeclSecurity] + la.blobSize
	case tableEventMap:
		return la.simpleSizes[tableTypeDef] + la.simpleSizes[tableEvent]
	case tableEvent:
		return 2 + la.stringSize + la.codedSizes[codedTypeDefOrRef]
	case tableExportedType:
		return 4 + 4 + la.stringSize + la.stringSize + la.codedSizes[codedImplementation]
	case tableField:
		return 2 + la.stringSize + la.blobSize
	case tableFieldLayout:
		return 4 + la.simpleSizes[tableField]
	case tableFieldMarshal:
		return la.codedSizes[codedHasFieldMarshal] + la.blobSize
	case tableFieldRVA:
		return 4 + la.simpleSizes[tableField]
	case tableFile:
		return 2 + la.stringSize + la.blobSize
	case tableGenericParam:
		return 2 + 2 + la.codedSizes[codedTypeOrMethodDef] + la.stringSize
	case tableGenericParamConstraint:
		return la.simpleSizes[tableGenericParam] + la.codedSizes[codedTypeDefOrRef]
	case tableImplMap:
		return 2 + la.codedSizes[codedMemberForwarded] + la.stringSize + la.simpleSizes[tableModuleRef]
	case tableInterfaceImpl:
		return la.simpleSizes[tableTypeDef] + la.codedSizes[codedTypeDefOrRef]
	case tableManifestResource:
		return 4 + 4 + la.stringSize + la.codedSizes[codedImplementation]
	case tableMemberRef:
		return la.codedSizes[codedMemberRefParent] + la.stringSize + la.blobSize
	case tableMethodDef:
		return 4 + 2 + 2 + la.stringSize + la.blobSize + la.simpleSizes[tableParam]
	case tableMethodImpl:
		return la.simpleSizes[tableTypeDef] + la.codedSizes[codedMethodDefOrRef] + la.codedSizes[codedMethodDefOrRef]
	case tableMethodSemantics:
		return 2 + la.simpleSizes[tableMethodDef] + la.codedSizes[codedHasSemantics]
	case tableMethodSpec:
		return la.codedSizes[codedMethodDefOrRef] + la.blobSize
	case tableModule:
		return 2 + la.stringSize + la.guidSize + la.guidSize + la.guidSize
	case tableModuleRef:
		return la.stringSize
	case tableNestedClass:
		return la.simpleSizes[tableTypeDef] + la.simpleSizes[tableTypeDef]
	case tableParam:
		return 2 + 2 + la.stringSize
	case tableProperty:
		return 2 + la.stringSize + la.blobSize
	case tablePropertyMap:
		return la.simpleSizes[tableTypeDef] + la.simpleSizes[tableProperty]
	case tableStandAloneSig:
		return la.blobSize
	case tableTypeDef:
		return 4 + la.stringSize + la.stringSize + la.codedSizes[codedTypeDefOrRef] + la.simpleSizes[tableField] + la.simpleSizes[tableMethodDef]
	case tableTypeRef:
		return la.codedSizes[codedResolutionScope] + la.stringSize + la.stringSize
	case tableTypeSpec:
		return la.blobSize
	default:
		panic(fmt.Sprintf("table %v not supported", t))
	}
}

// Define table decoding functions

func (rec *Assembly) decode(r recordReader) error {
	rec.HashAlgID = flags.AssemblyHashAlgorithm(r.uint32())
	rec.MajorVersion = r.uint16()
	rec.MinorVersion = r.uint16()
	rec.BuildNumber = r.uint16()
	rec.RevisionNumber = r.uint16()
	rec.Flags = flags.AssemblyFlags(r.uint32())
	rec.PublicKey = r.blob()
	rec.Name = r.string()
	rec.Culture = r.string()
	return r.err
}

func (rec *assemblyOS) decode(r recordReader) error {
	rec.OSPlatformID = r.uint32()
	rec.OSMajorVersion = r.uint32()
	rec.OSMinorVersion = r.uint32()
	return r.err
}

func (rec *assemblyProcessor) decode(r recordReader) error {
	rec.Processor = r.uint32()
	return r.err
}

func (rec *AssemblyRef) decode(r recordReader) error {
	rec.MajorVersion = r.uint16()
	rec.MinorVersion = r.uint16()
	rec.BuildNumber = r.uint16()
	rec.RevisionNumber = r.uint16()
	rec.Flags = flags.AssemblyFlags(r.uint32())
	rec.PublicKeyOrToken = r.blob()
	rec.Name = r.string()
	rec.Culture = r.string()
	rec.HashValue = r.blob()
	return r.err
}

func (rec *assemblyRefOS) decode(r recordReader) error {
	rec.OSPlatformID = r.uint32()
	rec.OSMajorVersion = r.uint32()
	rec.OSMinorVersion = r.uint32()
	rec.AssemblyRef = r.index(tableAssemblyRef)
	return r.err
}

func (rec *assemblyRefProcessor) decode(r recordReader) error {
	rec.Processor = r.uint32()
	rec.AssemblyRef = r.index(tableAssemblyRef)
	return r.err
}

func (rec *ClassLayout) decode(r recordReader) error {
	rec.PackingSize = r.uint16()
	rec.ClassSize = r.uint32()
	rec.Parent = r.index(tableTypeDef)
	return r.err
}

func (rec *Constant) decode(r recordReader) error {
	rec.Type = flags.ElementType(r.uint8())
	rec.Padding = r.uint8()
	rec.Parent = r.coded(codedHasConstant)
	rec.Value = r.blob()
	return r.err
}

func (rec *CustomAttribute) decode(r recordReader) error {
	rec.Parent = r.coded(codedHasCustomAttribute)
	rec.Type = r.coded(codedCustomAttributeType)
	rec.Value = r.blob()
	return r.err
}

func (rec *DeclSecurity) decode(r recordReader) error {
	rec.Action = r.uint16()
	rec.Parent = r.coded(codedHasDeclSecurity)
	rec.PermissionSet = r.blob()
	return r.err
}

func (rec *EventMap) decode(r recordReader) error {
	rec.Parent = r.index(tableTypeDef)
	rec.EventList = r.slice(tableEventMap, tableEvent)
	return r.err
}

func (rec *Event) decode(r recordReader) error {
	rec.EventFlags = flags.EventAttributes(r.uint16())
	rec.Name = r.string()
	rec.EventType = r.coded(codedTypeDefOrRef)
	return r.err
}

func (rec *ExportedType) decode(r recordReader) error {
	rec.Flags = flags.TypeAttributes(r.uint32())
	rec.TypeDefID = r.uint32()
	rec.Name = r.string()
	rec.Namespace = r.string()
	rec.Implementation = r.coded(codedImplementation)
	return r.err
}

func (rec *Field) decode(r recordReader) error {
	rec.Flags = flags.FieldAttributes(r.uint16())
	rec.Name = r.string()
	rec.Signature = r.blob()
	return r.err
}

func (rec *FieldLayout) decode(r recordReader) error {
	rec.Offset = r.uint32()
	rec.Field = r.index(tableField)
	return r.err
}

func (rec *FieldMarshal) decode(r recordReader) error {
	rec.Parent = r.coded(codedHasFieldMarshal)
	rec.NativeType = r.blob()
	return r.err
}

func (rec *FieldRVA) decode(r recordReader) error {
	rec.RVA = r.uint32()
	rec.Field = r.index(tableField)
	return r.err
}

func (rec *File) decode(r recordReader) error {
	rec.Flags = flags.FileAttributes(r.uint16())
	rec.Name = r.string()
	rec.HashValue = r.blob()
	return r.err
}

func (rec *GenericParam) decode(r recordReader) error {
	rec.Number = r.uint16()
	rec.Flags = flags.GenericParamAttributes(r.uint16())
	rec.Owner = r.coded(codedTypeOrMethodDef)
	rec.Name = r.string()
	return r.err
}

func (rec *GenericParamConstraint) decode(r recordReader) error {
	rec.Owner = r.index(tableGenericParam)
	rec.Constraint = r.coded(codedTypeDefOrRef)
	return r.err
}

func (rec *ImplMap) decode(r recordReader) error {
	rec.MappingFlags = flags.PInvokeAttributes(r.uint16())
	rec.MemberForwarded = r.coded(codedMemberForwarded)
	rec.ImportName = r.string()
	rec.ImportScope = r.index(tableModuleRef)
	return r.err
}

func (rec *InterfaceImpl) decode(r recordReader) error {
	rec.Class = r.index(tableTypeDef)
	rec.Interface = r.coded(codedTypeDefOrRef)
	return r.err
}

func (rec *ManifestResource) decode(r recordReader) error {
	rec.Offset = r.uint32()
	rec.Flags = flags.ManifestResourceAttributes(r.uint32())
	rec.Name = r.string()
	rec.Implementation = r.coded(codedImplementation)
	return r.err
}

func (rec *MemberRef) decode(r recordReader) error {
	rec.Class = r.coded(codedMemberRefParent)
	rec.Name = r.string()
	rec.Signature = r.blob()
	return r.err
}

func (rec *MethodDef) decode(r recordReader) error {
	rec.RVA = r.uint32()
	rec.ImplFlags = flags.MethodImplAttributes(r.uint16())
	rec.Flags = flags.MethodAttributes(r.uint16())
	rec.Name = r.string()
	rec.Signature = r.blob()
	rec.ParamList = r.slice(tableMethodDef, tableParam)
	return r.err
}

func (rec *MethodImpl) decode(r recordReader) error {
	rec.Class = r.index(tableTypeDef)
	rec.MethodBody = r.coded(codedMethodDefOrRef)
	rec.MethodDeclaration = r.coded(codedMethodDefOrRef)
	return r.err
}

func (rec *MethodSemantics) decode(r recordReader) error {
	rec.Semantics = flags.MethodSemanticsAttributes(r.uint16())
	rec.Method = r.index(tableMethodDef)
	rec.Association = r.coded(codedHasSemantics)
	return r.err
}

func (rec *MethodSpec) decode(r recordReader) error {
	rec.Method = r.coded(codedMethodDefOrRef)
	rec.Instantiation = r.blob()
	return r.err
}

func (rec *Module) decode(r recordReader) error {
	rec.Generation = r.uint16()
	rec.Name = r.string()
	rec.Mvid = r.guid()
	rec.EncID = r.guid()
	rec.EncBaseID = r.guid()
	return r.err
}

func (rec *ModuleRef) decode(r recordReader) error {
	rec.Name = r.string()
	return r.err
}

func (rec *NestedClass) decode(r recordReader) error {
	rec.NestedClass = r.index(tableTypeDef)
	rec.EnclosingClass = r.index(tableTypeDef)
	return r.err
}

func (rec *Param) decode(r recordReader) error {
	rec.Flags = flags.ParamAttributes(r.uint16())
	rec.Sequence = r.uint16()
	rec.Name = r.string()
	return r.err
}

func (rec *Property) decode(r recordReader) error {
	rec.Flags = flags.PropertyAttributes(r.uint16())
	rec.Name = r.string()
	rec.Type = r.blob()
	return r.err
}

func (rec *PropertyMap) decode(r recordReader) error {
	rec.Parent = r.index(tableTypeDef)
	rec.PropertyList = r.slice(tablePropertyMap, tableProperty)
	return r.err
}

func (rec *StandAloneSig) decode(r recordReader) error {
	rec.Signature = r.blob()
	return r.err
}

func (rec *TypeDef) decode(r recordReader) error {
	rec.Flags = flags.TypeAttributes(r.uint32())
	rec.Name = r.string()
	rec.Namespace = r.string()
	rec.Extends = r.coded(codedTypeDefOrRef)
	rec.FieldList = r.slice(tableTypeDef, tableField)
	rec.MethodList = r.slice(tableTypeDef, tableMethodDef)
	return r.err
}

func (rec *TypeRef) decode(r recordReader) error {
	rec.ResolutionScope = r.coded(codedResolutionScope)
	rec.Name = r.string()
	rec.Namespace = r.string()
	return r.err
}

func (rec *TypeSpec) decode(r recordReader) error {
	rec.Signature = r.blob()
	return r.err
}
